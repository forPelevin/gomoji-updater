package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"text/template"

	"github.com/forPelevin/gomoji"
	"github.com/forPelevin/gomoji-updater/pkg/unicodefile"
)

var (
	outputPath = flag.String("output", "./data.go", "path to write generated data")
)

func main() {
	flag.Parse()

	existingEmojis := gomoji.AllEmojis()
	emojiMap := make(map[string]gomoji.Emoji, len(existingEmojis))
	for _, e := range existingEmojis {
		emojiMap[e.Character] = e
	}

	provider := unicodefile.NewProvider()
	newEmojis, err := provider.AllEmojis(context.Background())
	if err != nil {
		log.Fatalf("fetch emojis: %s", err)
	}

	for _, e := range newEmojis {
		if e.Slug == "" {
			log.Printf("emoji %+v has no slug", e)
			continue
		}
		if _, exists := emojiMap[e.Character]; !exists {
			emojiMap[e.Character] = e
		}
	}

	tplFile, err := template.New("data").Parse(textTplFile)
	if err != nil {
		log.Fatalf("parse template: %s", err)
	}

	output, err := os.Create(*outputPath)
	if err != nil {
		log.Fatalf("create output file: %s", err)
	}
	defer output.Close()

	if err = tplFile.Execute(output, emojiMap); err != nil {
		log.Fatalf("execute template: %s", err)
	}

	fmt.Printf("%d Emoji entities generated\n", len(emojiMap))
}

const (
	textTplFile = `// Code generated by generator.go ; DO NOT EDIT.

package gomoji

var (
	emojiMap = map[string]Emoji{
		{{ range $index, $val  := . }}"{{ $index }}": {Slug:"{{ $val.Slug }}",Character:"{{ $val.Character }}",UnicodeName:"{{ $val.UnicodeName }}",CodePoint:"{{ $val.CodePoint }}",Group:"{{ $val.Group }}",SubGroup:"{{ $val.SubGroup }}"},
		{{ end }}
	}
)`
)
